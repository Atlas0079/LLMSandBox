# LLM-Driven Agent Society Simulation Engine
## 基于大语言模型的智能体社会仿真演化系统

### 1. 摘要

项目的最终目的是实现一个多智能体仿真系统，用来观察大语言模型 (LLM) 驱动的智能体在动态环境中的决策与交互过程。
系统会提供一个开放式的虚拟环境，智能体在其中感知局部信息、提出行动请求，并由系统规则执行后更新世界状态。
相比完全依赖预设脚本的方式，本项目更关注“规则约束下的自主行为”在长时间运行中的表现与局限。

---

### 2. 核心概念定义

#### 2.1 离散时间仿真

系统的时间被切分为一个个固定的时间步 (Ticks)。
在每个时间步 $t$，系统**按顺序**调度所有智能体。每个智能体根据**即时的世界状态**（包括同一时间步内排在它前面的智能体所造成的改变）进行感知与决策，生成的动作会被立即执行并更新世界状态。这意味着排在后面的智能体可以看到排在前面的智能体刚刚完成的行为结果。

#### 2.2 开放式环境

系统不设定固定的“剧情目标”或“预设任务流程”。
环境由离散的**实体 (Entities)** 组成（如资源、工具、建筑）。
环境也由离散的**地点 (Locations)** 组成：地点是空间上的基本节点，用于承载“谁和谁在同一个地方、因此能看见/能交互”的规则。
系统仅定义原子级的**物理交互逻辑**（如“进食”增加能量，“砍伐”消耗体力并产出木材），不限制智能体如何使用这些规则。
在此基础上，系统允许智能体在资源与约束条件下持续交互，观察是否会出现更复杂的协作或分工现象。

#### 2.3 符号落地

这是本系统的核心技术难点。LLM 输出的是抽象的自然语言（如“我想吃那个红色的苹果”），而计算机系统只能执行精确的指令（如 `Consume(Target_ID=1024)`）。本系统设计了**双层认知架构**来解决这一“语言-行为”的鸿沟（见第四节）。

---

### 3. 系统架构

系统采用**数据驱动** 与 **模块化状态** 设计。

#### 3.0 数据驱动的动机
本项目将“实体模板”和“交互配方”尽量外置为数据（例如 JSON），主要考虑两点：
-   数据结构清晰，便于让 LLM 在给定约束下对已有模板与配方进行一致性检查。
-   长期目标是引入一个“上帝 Agent”（世界编辑器），它不直接扮演世界中的普通角色，而是在受限权限下对“世界公理”进行调整（例如：增删配方、修改模板参数、调整资源生成率）。该类修改需要经过结构校验与规则验证后才会生效，以避免不合法的配置破坏仿真。

#### 3.1 仿真内核
仿真内核可以理解为系统的“调度器 + 写入口”，负责让世界以可控、可复现的方式推进。它的目标不是“把所有行为算得很真实”，而是把**状态更新的边界**划清楚，让调试与扩展变得简单。
-   **单一事实来源**：所有世界数据都集中在 `WorldState` 中（实体、地点、容器、任务、时间与日志）。其他模块只读取它，或通过约定好的接口提交变更请求。
-   **时间推进**：每个 Tick 先推进时间，再驱动各实体/组件的 `per_tick` 逻辑，让“衰减”“任务进度”“认知决策”等都能按统一节拍发生。
-   **序列化执行**：在同一个 Tick 内按顺序处理实体，避免并发冲突；并且使后续决策看到最新世界。
-   **唯一写入口**：组件不直接改 `WorldState` 的细节，而是把变更拆成原子 `Effect` 放入队列；最终由执行器逐条落地，保证状态变更路径一致、可记录、可回放。
-   **事件与观测**：每次 Tick 与每条 Effect 的执行都会产生事件记录，既用于调试，也用于为感知系统提供“最近发生了什么”的可读叙事输入。

#### 3.2 实体-组件模型 (Entity-Component Model)

-   **实体 (Entity)**：实体的本质仅仅是一个**唯一标识符 (ID)**。它本身不包含任何逻辑或数据，就像一个空的容器。
-   **组件 (Component)**：组件是**功能特性与数据的原子化封装**。它是赋予实体具体“意义”的最小单元，本质上是一种“能力契约”。
    -   **作为数据载体 (Data Container)**：组件存储特定的状态数据。
        -   *Example*: `CreatureComponent` 维护了生物体的生理稳态指标（如营养值、水分值），定义了该实体在生物学层面的存在。
    -   **作为行为许可 (Behavioral Enabler)**：组件的挂载激活了特定的系统逻辑。
        -   *Example*: 只有挂载了 `AgentControlComponent`，**认知系统**才会介入，为该实体分配 LLM 计算资源并接管其决策权。
        -   *Example*: 只有挂载了 `ContainerComponent`，**物理系统**才允许该实体在空间上“容纳”其他物体（如作为背包或箱子）。
    - 这种解耦设计使得开发者可以通过“搭积木”的方式自由定义实验对象，无需修改底层代码即可验证不同的假设。

##### 3.2.1 Location 与空间结构 (Spatial Model)

-   **Location**：地点是离散空间的基本节点，维护“这个地点当前有哪些实体”的索引，并可通过连接关系形成一个地点图（例如：A 地点可以走到 B 地点）。
-   **Entity ↔ Location**：一个地点通常包含多个实体；一个实体在同一时刻通常只应处在一个地点（或处在某个容器内，而该容器处在某个地点）。
-   **Location 与感知/交互**：感知系统通常以“当前 Location”为边界收集可见实体；交互系统也通常要求目标实体与行动者在同一 Location（或满足容器可见性）才能匹配 recipe。
-   **Container 是 Location 的补充**：Location 解决“在同一地点”的空间关系；Container 解决“在同一地点里又被收纳/遮挡”的层级关系（例如背包内物品可能不可见）。

#### 3.3 组件库概览 (Component Library)

##### 已实现组件 (Implemented)
-   **基础属性类**
    -   `TagComponent`: **语义标签系统**。为实体打上 "Edible" (可食), "Flammable" (易燃) 等标签，供交互规则 (`Recipes`) 匹配。
    -   `AgentComponent`: **身份定义**。存储智能体的姓名、性格描述 (Persona) 与基础常识。
-   **生理与生存类**
    -   `CreatureComponent`: **生物体征**。维护生命值 (HP)、能量 (Energy)、饱腹度 (Nutrition) 等稳态指标，模拟熵增导致的自然衰减。
-   **能力与行为类**
    -   `WorkerComponent`: **劳动引擎**。赋予实体执行长周期任务 (Task) 的能力（如 "正在砍树 (30%)"），并管理任务进度。
    -   `ContainerComponent`: **空间容器**。允许实体内部存储其他物体（如背包、箱子），支持无限层级的递归嵌套。
-   **决策与控制类**
    -   `AgentControlComponent`: **认知接口**。连接 LLM 的桥梁，负责将感知数据上行发送给模型，并将模型生成的自然语言意图下行解析为指令。
    -   `DecisionArbiterComponent`: **决策仲裁器**。基于规则判断是否需要打断当前行为（如“饿了”或“任务完成”），触发新的 OODA 循环。
    -   `TaskHostComponent`: **计划管理**。维护智能体的待办事项队列 (Task Queue)。

##### 规划中组件 (Planned)
-   `MemoryComponent`: **长期记忆接口**。对接向量数据库，用于情境记忆的存储与检索。
-   `SocialComponent`: **社会关系表征**。维护亲密度/信任等状态，用于驱动更复杂的互动策略。
-   `SkillComponent`: **技能与熟练度**。将效率/成功率与经验积累关联，支持更稳定的长期行为差异。
-   `WorldEditorAgent`：**元级控制器**。在受限权限下审查并修改实体模板与配方（“世界公理”），用于快速迭代与实验对比。


---

### 4. 智能体认知架构

智能体是具备**OODA 循环 (观察-调整-决策-行动)** 的认知实体。具有两个层，可以分别调用不同的 LLM 模型。

#### 4.1 认知分层
-   **Layer 1: 规划层 (Planner)**
    -   输入：智能体自述信息（姓名/性格/常识摘要）、当前时间步信息、当前地点与可见实体列表、最近交互记录、当前触发原因（如“营养过低/任务完成”）。
    -   输出：自然语言形式的意图与简要计划（不包含可执行的低层指令）。
    -   功能：在给定约束与有限感知下，形成“下一阶段要做什么”的高层决策。
    -   *Example*: "我现在能量较低，先寻找可食物品补充营养。"
-   **Layer 2: 执行层 (Grounder)**
    -   输入：规划层输出的意图文本、可用动词集合（由现有 Recipe 与可见目标共同决定）、可见实体列表与其 id、必要的上下文（例如上一轮失败原因）。
    -   输出：结构化的动作请求列表（Action），每条包含 `verb`、`target_id` 与可选 `parameters`。
    -   功能：把自然语言意图映射为“系统允许且语法正确”的动作请求；若动作不符合规则，将在后续由配方引擎拒绝并记录失败原因。
    -   *Example*: 生成 `{"verb": "PickUp", "target_id": "Apple_01", "parameters": {}}`。

#### 4.2 交互
系统的物理规则定义在外部数据文件 (`Recipes.json`) 中，构成了世界的**公理体系**。在实现上，LLM 并不能“直接改世界”，它必须先提出一个结构化请求，由系统根据规则翻译并执行。为此，引擎将交互拆分为四个概念，并形成固定的数据流：

1.  **Action (动作)**：智能体提出的“交互申请”，本质是一个**填写好的表单**。
    -   *定义*：`verb`（动作名）+ `target_id`（目标实体）+ `parameters`（可选参数）。Action 本身不修改世界，只描述“我想做什么、对谁做”。  
    -   *通俗理解*：*比如“我想砍这棵树”。这时候还没动手。*
2.  **Recipe (配方)**：世界允许的行为白名单，是一个**从 Action 到效果序列的查表规则**。
    -   *匹配*：引擎依据 `verb` + 目标的 `Tags` + 参数约束来匹配 recipe；匹配不到就拒绝（例如 `NO_TARGET` / `NO_RECIPE`）。  
    -   *通俗理解*：*系统会查表：砍树需要什么条件？目标必须有 Wood 标签；并且这件事不是瞬间完成的，需要一段时间。*
3.  **Task (持续性任务)**：当 recipe 声明需要耗时时，Action 不会直接产生最终结果，而会被翻译为一个可推进的过程状态。
    -   *机制*：系统先产生 `CreateTask` 效果创建任务；随后由 `WorkerComponent` 在每个 Tick 推进进度，必要时产生 `tick_effects`；完成时触发 `FinishTask` 并执行固化在任务中的 completion effects。  
    -   *通俗理解*：*Action 匹配成功后，智能体会被占用，直到任务完成或被中断。*
4.  **Effect (原子状态变更)**：对 `WorldState` 的**唯一写入口**，由执行器逐条执行。
    -   *定义*：Effect 是最小的世界变更算子。Recipe 的 outputs 会被拆成一系列 effect，按顺序执行。  
    -   *通俗理解*：*当任务完成，系统才会真正修改世界：树被销毁、产出木头、体力发生变化等。*

> **链式流程**: Agent 发起 `Action` $\rightarrow$ 匹配 `Recipe` $\rightarrow$ 实例化 `Task` $\rightarrow$ 随时间产出 `Effect` $\rightarrow$ 修改 `WorldState`。

---

### 5. 开发路线

本项目目前处于原型阶段，核心框架已经可以端到端运行。下面按阶段列出已完成部分与后续计划。

#### 已完成的部分
    -   已实现离散时间步驱动的世界状态演化 (`WorldState` + `WorldManager.step()`)，支持 Tick 级事件记录，用于调试与回放。
    -   已实现基于实体-组件的建模方式，支持通过模板和组件组合构造不同类型的实体（智能体、物品、容器等）。
    -   已支持 Location 与 Container 的组合索引：实体既可以直接处于地点，也可以被收纳于多层嵌套的容器中，并通过感知系统控制可见性。
    -   已实现从 Action → Recipe → Task → Effect 的完整链路，包括即时效果与随时间推进的持续性任务（如进食、休息类行为）。
    -   已实现 Planner + Grounder 的双层架构：Planner 负责高层意图生成，Grounder 负责将意图翻译为受约束的动作请求；动作再由配方引擎与执行器落地到世界状态。
    -   已实现基于规则的 DecisionArbiter，可以在饥饿、任务完成等条件下中断当前任务，触发新一轮决策。

#### 未来规划
-   首先还是要引入长期记忆与情境记忆组件，最近在研究LightRAG。
-   目前Path还没有实际完成，地点之间是没有连接的。
-   需要实现额外的组件，这取决于我们想要模拟一个什么样的环境。比如要想模拟几个农庄里干活的农夫，可能就需要农作物相关的组件、实体模板、配方。
-   增加多智能体之间的显式通信动作，观察简单社会结构的出现。
-   加入“WorldEditorAgent”，用于审查和调整实体模板与配方，支持不同“世界设定”的对比实验。
-   利用“上帝模型”来扩充实体模板数量和配方数量，以支持更复杂的世界模拟。
---
